
## Possible imports?
from . import view, view_list, utils # get_sector_dates
import numpy as np


def summarize_html( observations, sectors, cameras, ncycle=0):
    """Prints summary stats for HTML output"""
    num=len(observations)


    print('<div><table class="table-condensed"><tr><th>Summary</th><th>number</th><th>fraction</th></tr>\n'.format(num))

    print("<td>Number of sources with at least 1 observation:  </td><td> {:d} </td><td> {:.1f}% </td></tr>".format( len([o for o in observations if o > 0]) , 100.*float(len([o for o in observations if o > 0]))/float(num)) )

    print("<td>Number of sources with at least 2 observations:  </td><td> {:d} </td><td> {:.1f}% </td></tr>".format( len([o for o in observations if o > 1]) , 100.*float(len([o for o in observations if o > 1]))/float(num)) )

    print("<td>Number of sources not observed:  </td><td> {:d} </td><td> {:.1f}% </td></tr>".format( len([o for o in observations if o == 0]) , 100.*float(len([o for o in observations if o == 0]))/float(num) ))

    for s in range(1,14):
        print("<td>Number of sources observed in Sector {:d}:  </td><td> {:d} </td><td> {:.1f}% </td></tr>".format(s+ncycle*13, sectors[s-1]))
    for c in range(1,5):
        print("<td>Number of sources observed in Camera {:d} </td><td>  {:d} </td><td> - </td></tr>".format(c, cameras[c-1] ))

       
    print("</table>")
    print("<p>(Feel free to write to the helpdesk to suggest other useful stats!)</p>\n")
    print("</div>")



def summarize( observations, sectors, cameras, ncycle=0):
    """Prints summary stats for screen output
    
    TBD  Add string formatting into columns on-screen
    """


    num=len(observations)

    print('<div><table class="table-condensed"><tr><th>Summary</th><th>number</th><th>fraction</th></tr>\n'.format(num))

    print("<td>Number of sources with at least 1 observation:  </td><td> {:d} </td><td> {:.1f}% </td></tr>".format( len([o for o in observations if o > 0]) , 100.*float(len([o for o in observations if o > 0]))/float(num)) )

    print("<td>Number of sources with at least 2 observations:  </td><td> {:d} </td><td> {:.1f}% </td></tr>".format( len([o for o in observations if o > 1]) , 100.*float(len([o for o in observations if o > 1]))/float(num)) )

    print("<td>Number of sources not observed:  </td><td> {:d} </td><td> {:.1f}% </td></tr>".format( len([o for o in observations if o == 0]) , 100.*float(len([o for o in observations if o == 0]))/float(num) ))

    for s in range(1,14):
        print("<td>Number of sources observed in Sector {:d}:  </td><td> {:d} </td><td> {:.1f}% </td></tr>".format(s+ncycle*13, sectors[s-1]))
    for c in range(1,5):
        print("<td>Number of sources observed in Camera {:d} </td><td>  {:d} </td><td> - </td></tr>".format(c, cameras[c-1] ))

       
    print("</table>")
    print("<p>(Feel free to write to the helpdesk to suggest other useful stats!)</p>\n")
    print("</div>")









def summarize_list(stats,ncycle=0):
    """ Compute summary statistics to be printed with either summarize_html() or summarize()
    """
    num=stats.shape[0]
    
    observations=[len([s for s in stats[row,2:15] if s > 0]) for row in range(num)]
    sectors=np.zeros(13,type=int)
    cameras=np.zeros(5)

    for s in range(1,14):
        sectors[s-1]=len([c for c in stats[:,s+1] if c > 0]), 100.*float(len([c for c in stats[:,s+1] if c > 0]))/float(num) 

    ## Count how many sources are observed in each camera.
    for c in range(1,5):
        cameras[c-1]=sum([1 for r in range(0,num) if c in stats[r,2:-1] ])
 
    return observations, sectors, cameras 




def parse_input(fileitem):
    """Double-check the results of tvguide's parse_file, which currently uses numpy.genfromtxt

    Converts to floats just to be sure, also replaces \r Windows-style
    newlines which aren't parsed correctly.

    """
    assert fileitem is not None
    if debug:  print("<p>DEBUGGING: got into parse_input() with fileitem is %s</p>"%fileitem)
    if debug and fileitem.value:  print("<p>DEBUGGING: got into parse_input() with fileitem.value</p>")
    try:
        if not hasattr(fileitem,'file') and type(fileitem) is str:
            # Given a file on disk for testing
            if debug:  print("<p>DEBUGGING:  fileitem is str, calling tvguide's parse_file</p>")
            if not os.path.isfile(fileitem):
                print("ERROR:  cannot find fileitem '%s'"%fileitem)
                exit(1)
            inra,indec=parse_file(fileitem,exit_on_error=False)
        elif fileitem.value:  
            from io import cStringIO
            #  Given through POST data?  
            if debug:  print("<p>DEBUGGING:  fileitem has key 'file' in parse_file, trying to parse it as a string</p>")
            inra,indec=parse_file(cStringIO.StringIO(fileitem.value),exit_on_error=False)
        else:
            #  Given a file-like object from the cgi FieldStorage
            if debug:  print("<p>DEBUGGING:  fileitem is NOT str, assuming an opened object, calling fileitem.file.readline()</p>")
            first=fileitem.file.readline()
            second=fileitem.file.readline()
            # reset it to the beginning after reading the first line, otherwise parse_file() will be missing it!
            fileitem.file.seek(0) 
            if '\r' in first or '\r' in second:
                if debug:  print("<p>DEBUGGING: Found '\\r' in first='%s';  calling reline_input. </p>"%first)
                inra,indec=reline_input(fileitem.file)
            else:
                inra,indec=parse_file(fileitem.file,exit_on_error=False)
                inra=inra.tolist()
                indec=indec.tolist()
    except Exception as e:
        print("<p><font color=red>Problem reading file</font>:  Exception %s</p>"%e)

    ra=np.zeros(len(inra))
    dec=np.zeros(len(indec))
    bad=0
    for i in range(len(inra)):
        try:
            ra[i]=float(inra[i])
        except Exception as e:
            bad+=1
            ra[i]=np.nan
    for i in range(len(indec)):
        try:
            dec[i]=float(indec[i])
        except Exception as e:
            bad+=1
            dec[i]=np.nan
    return ra,dec,bad



def parse_file(infile, exit_on_error=True):
    """Parse a comma-separated file with columns "ra,dec,magnitude".  From TomB's tvguide wrapper.  
    """
    try:
        a, b = np.atleast_2d(
            np.genfromtxt(
                infile,
                usecols=[0, 1],
                delimiter=',',
                comments='#',
                skip_header=0,
                dtype="f8"
            )
        ).T
    except:
        try: 
            a, b = np.atleast_2d(
                np.genfromtxt(
                    infile,
                    delimiter=',',
                    skip_header=0,
                    dtype="f8"
                )
            ).T
        except IOError as e:
            print("There seems to be a problem with the input file, "
                     "the format should be: RA_degrees (J2000), Dec_degrees (J2000). "
                     "There should be no header, columns should be "
                     "separated by a comma")
            if exit_on_error:
                sys.exit(1)
            else:
                raise e
    return a, b


def csv_header():
    from webtess import get_sector_dates
    cycles=[1,2]
    header=""
    for cycle in cycles:
        header+="\n# For TESS observing Cycle {}\n# ".format(cycle)
        dates=get_sector_dates(cycle=cycle)
        header+="\n# ".join([ "Sector {:2d} observed {}".format(s+13*(cycle-1),d) for s,d in enumerate(dates,1)])
        if debug:  print("<p>DEBUGGING:  header is {}</p>".format(header))
    header+="\n#\n#RA,DEC,"
    for i in range(13*len(cycles)-1):
        header+="S{},".format(i+1)
    header+="S{}".format(len(cycles)*13)
    return header

def main(relpath):
